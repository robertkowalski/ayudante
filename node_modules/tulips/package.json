{
  "author": {
    "name": "Robert Kowalski",
    "email": "rok@kowalski.gd"
  },
  "name": "tulips",
  "description": "An ini encoder/decoder for node that can handle multiple keys",
  "version": "0.0.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/robertkowalski/tulips.git"
  },
  "main": "lib/tulips.js",
  "scripts": {
    "pretest": "make && standard",
    "prepublish": "npm t && make",
    "test": "tap test/*.js",
    "babel": "babel"
  },
  "dependencies": {
    "ini": "^1.3.4"
  },
  "bundleDependencies": [
    "ini"
  ],
  "standard": {
    "ignore": [
      "lib/**"
    ]
  },
  "devDependencies": {
    "babel-cli": "^6.5.1",
    "babel-preset-es2015": "^6.5.0",
    "standard": "^4.0.1",
    "tap": "^2.0.0"
  },
  "license": "ISC",
  "gitHead": "21f85eb48d7dda01c261c5d30b9c1db3a02f909d",
  "readme": "# tulips\n\nAn ini format parser and serializer for node which can handle\nmultiple keys. Based on [ini](https://github.com/npm/ini)\ntulips has a data model based on tuples which can handle multiple keys.\ntulips is needed for ini files with multiple keys that have the same,\ne.g. to handle multiple fetch sources in a `.git/config` file.\n\n\n## Usage\n\nConsider an ini-file `.git/config` that looks like this:\n\n```ini\n[remote \"origin\"]\n    fetch = +refs/heads/*:refs/remotes/origin/*\n    url = git@github.com:joyent/node.git\n```\n\nYou can read, manipulate and write the ini-file like so:\n\n```js\nconst tulips = require('tulips')\n\nconst parsed = tulips.parse(initialFile)\nconst changed = parsed.map(el => {\n  const section = Object.keys(el)[0]\n\n  if (section !== 'remote \"origin\"') return el\n\n  const hasPrRelatedRemote = el[section].some(\n    el => el.fetch && el.fetch === '+refs/pull/*/head:refs/remotes/origin/pr/*'\n  )\n\n  if (hasPrRelatedRemote) return\n\n  el[section].push({fetch: '+refs/pull/*/head:refs/remotes/origin/pr/*'})\n\n  return el\n})\n\nconsole.log(tulips.stringify(changed, {whitespace: true}))\n```\n\nThis will print this modified content:\n\n```ini\n[remote \"origin\"]\nfetch = +refs/heads/*:refs/remotes/origin/*\nurl = git@github.com:joyent/node.git\nfetch = +refs/pull/*/head:refs/remotes/origin/pr/*\n```\n\n## Todo\n\n - Parsing of nested sections, e.g. `[section.database.user]`\n\n\n## API\n\n### decode(inistring)\n\nDecode the ini-style formatted `inistring` into a nested object.\n\n### parse(inistring)\n\nAlias for `decode(inistring)`\n\n### encode(object, [options])\n\nEncode the object `object` into an ini-style formatted string. If the\noptional parameter `section` is given, then all top-level properties\nof the object are put into this section and the `section`-string is\nprepended to all sub-sections, see the usage example above.\n\nThe `options` object may contain the following:\n\n* `section` A string which will be the first `section` in the encoded\n  ini data.  Defaults to none.\n* `whitespace` Boolean to specify whether to put whitespace around the\n  `=` character.  By default, whitespace is omitted, to be friendly to\n  some persnickety old parsers that don't tolerate it well.  But some\n  find that it's more human-readable and pretty with the whitespace.\n\nFor backwards compatibility reasons, if a `string` options is passed\nin, then it is assumed to be the `section` value.\n\n### stringify(object, [options])\n\nAlias for `encode(object, [options])`\n\n### safe(val)\n\nEscapes the string `val` such that it is safe to be used as a key or\nvalue in an ini-file. Basically escapes quotes. For example\n\n    ini.safe('\"unsafe string\"')\n\nwould result in\n\n    \"\\\"unsafe string\\\"\"\n\n### unsafe(val)\n\nUnescapes the string `val`\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/robertkowalski/tulips/issues"
  },
  "homepage": "https://github.com/robertkowalski/tulips#readme",
  "_id": "tulips@0.0.0",
  "_shasum": "fdb93fe530e908461acfcd1fb80e0a39e315ff7d",
  "_from": "../tulips",
  "_resolved": "file:../tulips"
}
